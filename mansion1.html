<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Luxury Mansion at Night - Three.js</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 14px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 5px;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 18px;
            z-index: 200;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>üè∞ Luxury Mansion at Night</h3>
        <p>Camera rotating around mansion</p>
        <p>Watch the spotlights, reflections, and night lighting</p>
    </div>
    <div id="loading">Loading scene...</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0e27);
        scene.fog = new THREE.Fog(0x0a0e27, 200, 500);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(50, 35, 60);
        camera.lookAt(0, 20, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, precision: 'highp' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.1;
        renderer.physicallyCorrectLights = true;
        renderer.shadowMap.needsUpdate = true;
        document.body.appendChild(renderer.domElement);

        // Lighting
        // Ambient light for overall scene illumination
        const ambientLight = new THREE.AmbientLight(0x1a1a2e, 0.4);
        scene.add(ambientLight);

        // Moon light
        const moonLight = new THREE.DirectionalLight(0x4a7ba7, 0.6);
        moonLight.position.set(100, 80, 50);
        moonLight.castShadow = true;
        moonLight.shadow.mapSize.width = 4096;
        moonLight.shadow.mapSize.height = 4096;
        moonLight.shadow.camera.far = 300;
        moonLight.shadow.camera.left = -150;
        moonLight.shadow.camera.right = 150;
        moonLight.shadow.camera.top = 150;
        moonLight.shadow.camera.bottom = -150;
        moonLight.shadow.bias = -0.004;
        scene.add(moonLight);

        // Spotlights for the mansion
        const spotlights = [
            { pos: [30, 40, -30], color: 0xffffff, angle: Math.PI / 8 },
            { pos: [-30, 40, -30], color: 0xffcc99, angle: Math.PI / 8 },
            { pos: [40, 35, 20], color: 0xccffff, angle: Math.PI / 6 },
            { pos: [-40, 35, 20], color: 0xffccff, angle: Math.PI / 6 },
            { pos: [0, 50, 40], color: 0xffffcc, angle: Math.PI / 10 },
        ];

        const spotLightObjects = [];
        spotlights.forEach(light => {
            const spotlight = new THREE.SpotLight(light.color, 2, 150, light.angle, 0.5, 2);
            spotlight.position.set(...light.pos);
            spotlight.castShadow = true;
            spotlight.shadow.mapSize.width = 2048;
            spotlight.shadow.mapSize.height = 2048;
            spotlight.target.position.set(0, 10, 0);
            scene.add(spotlight);
            scene.add(spotlight.target);
            spotLightObjects.push({ light: spotlight, angle: light.angle, originalColor: light.color });
        });

        // Create mansion
        const mansionGroup = new THREE.Group();
        
        // Main building
        const mainBuildingGeometry = new THREE.BoxGeometry(60, 40, 50);
        const mainBuildingMaterial = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.4,
            metalness: 0.1
        });
        const mainBuilding = new THREE.Mesh(mainBuildingGeometry, mainBuildingMaterial);
        mainBuilding.castShadow = true;
        mainBuilding.receiveShadow = true;
        mainBuilding.position.y = 20;
        mansionGroup.add(mainBuilding);

        // Roof
        const roofGeometry = new THREE.ConeGeometry(90, 20, 4);
        const roofMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            roughness: 0.6,
            metalness: 0.05
        });
        const roof = new THREE.Mesh(roofGeometry, roofMaterial);
        roof.castShadow = true;
        roof.receiveShadow = true;
        roof.position.y = 50;
        roof.rotation.y = Math.PI / 4;
        mansionGroup.add(roof);

        // Left wing
        const leftWingGeometry = new THREE.BoxGeometry(30, 35, 45);
        const leftWing = new THREE.Mesh(leftWingGeometry, mainBuildingMaterial);
        leftWing.castShadow = true;
        leftWing.receiveShadow = true;
        leftWing.position.set(-45, 17.5, 0);
        mansionGroup.add(leftWing);

        // Right wing
        const rightWingGeometry = new THREE.BoxGeometry(30, 35, 45);
        const rightWing = new THREE.Mesh(rightWingGeometry, mainBuildingMaterial);
        rightWing.castShadow = true;
        rightWing.receiveShadow = true;
        rightWing.position.set(45, 17.5, 0);
        mansionGroup.add(rightWing);

        // Front portico
        const porticoGeometry = new THREE.BoxGeometry(50, 15, 8);
        const porticoMaterial = new THREE.MeshStandardMaterial({
            color: 0xcccccc,
            roughness: 0.3,
            metalness: 0.2
        });
        const portico = new THREE.Mesh(porticoGeometry, porticoMaterial);
        portico.castShadow = true;
        portico.receiveShadow = true;
        portico.position.set(0, 20, -30);
        mansionGroup.add(portico);

        // Columns for portico
        const columnGeometry = new THREE.CylinderGeometry(3, 3.5, 16, 16);
        const columnMaterial = new THREE.MeshStandardMaterial({
            color: 0xf5f5f5,
            roughness: 0.2,
            metalness: 0.1
        });
        
        const columnPositions = [
            [-20, 8, -28], [-10, 8, -28], [0, 8, -28],
            [10, 8, -28], [20, 8, -28]
        ];
        
        columnPositions.forEach(pos => {
            const column = new THREE.Mesh(columnGeometry, columnMaterial);
            column.castShadow = true;
            column.receiveShadow = true;
            column.position.set(...pos);
            mansionGroup.add(column);
        });

        // Windows with emissive glow
        const windowMaterial = new THREE.MeshStandardMaterial({
            color: 0xffff99,
            emissive: 0xffff99,
            emissiveIntensity: 0.8,
            roughness: 0.1,
            metalness: 0.3
        });

        const windowGeometry = new THREE.BoxGeometry(4, 4, 0.5);
        const windowPositions = [
            [-20, 25, -31], [-8, 25, -31], [8, 25, -31], [20, 25, -31],
            [-20, 35, -31], [-8, 35, -31], [8, 35, -31], [20, 35, -31],
            [-25, 25, 5], [-25, 35, 5],
            [25, 25, 5], [25, 35, 5],
            [-35, 25, 0], [-35, 35, 0],
            [35, 25, 0], [35, 35, 0],
        ];

        windowPositions.forEach(pos => {
            const window = new THREE.Mesh(windowGeometry, windowMaterial);
            window.castShadow = true;
            window.receiveShadow = true;
            window.position.set(...pos);
            mansionGroup.add(window);
        });

        // Door
        const doorGeometry = new THREE.BoxGeometry(6, 10, 0.5);
        const doorMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b4513,
            roughness: 0.4,
            metalness: 0.3
        });
        const door = new THREE.Mesh(doorGeometry, doorMaterial);
        door.castShadow = true;
        door.receiveShadow = true;
        door.position.set(0, 8, -31);
        mansionGroup.add(door);

        scene.add(mansionGroup);

        // Ground with reflection surface
        const groundGeometry = new THREE.PlaneGeometry(400, 400);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.35,
            metalness: 0.4
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // Reflective water feature
        const poolGeometry = new THREE.PlaneGeometry(80, 60);
        const poolMaterial = new THREE.MeshStandardMaterial({
            color: 0x071629,
            roughness: 0.05,
            metalness: 0.95
        });
        const pool = new THREE.Mesh(poolGeometry, poolMaterial);
        pool.rotation.x = -Math.PI / 2;
        pool.position.set(0, 0.02, 60);
        pool.receiveShadow = true;
        scene.add(pool);

        // Surrounding elements
        const treeGeometry = new THREE.ConeGeometry(8, 25, 8);
        const treeMaterial = new THREE.MeshStandardMaterial({
            color: 0x0a3a0a,
            roughness: 0.8
        });

        const treePositions = [
            [-80, 0, -50], [80, 0, -50], [-80, 0, 50], [80, 0, 50],
            [-100, 0, 0], [100, 0, 0]
        ];

        treePositions.forEach(pos => {
            const tree = new THREE.Mesh(treeGeometry, treeMaterial);
            tree.castShadow = true;
            tree.receiveShadow = true;
            tree.position.set(...pos);
            scene.add(tree);
        });

        // Stars
        const starsGeometry = new THREE.BufferGeometry();
        const starsMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.5,
            sizeAttenuation: true
        });

        const starsVertices = [];
        for (let i = 0; i < 500; i++) {
            const x = (Math.random() - 0.5) * 400;
            const y = Math.random() * 300 + 100;
            const z = (Math.random() - 0.5) * 400;
            starsVertices.push(x, y, z);
        }

        starsGeometry.setAttribute('position', new THREE.BufferAttribute(new Float32Array(starsVertices), 3));
        const stars = new THREE.Points(starsGeometry, starsMaterial);
        scene.add(stars);

        // Camera movement
        const cameraOrbit = {
            radius: 80,
            angle: 0,
            height: 35,
            speed: 0.0005
        };

        function updateCamera() {
            cameraOrbit.angle += cameraOrbit.speed;
            const x = Math.cos(cameraOrbit.angle) * cameraOrbit.radius;
            const z = Math.sin(cameraOrbit.angle) * cameraOrbit.radius;
            const y = cameraOrbit.height + Math.sin(cameraOrbit.angle * 0.7) * 2;
            camera.position.set(x, y, z);
            camera.lookAt(0, 20, 0);
        }

        // Spotlight animation
        let spotlightTime = 0;
        function updateSpotlights() {
            spotlightTime += 0.01;
            spotLightObjects.forEach((sl, index) => {
                const flickerOffset = Math.sin(spotlightTime * 0.5 + index) * 0.1;
                sl.light.intensity = 2 + flickerOffset;
            });
        }

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Hide loading message
        document.getElementById('loading').style.display = 'none';

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            updateCamera();
            updateSpotlights();

            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
